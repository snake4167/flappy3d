<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>3D Flappy Bird — Bird POV</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#87CEEB;}
    #overlay {
      position: absolute; left: 10px; top: 10px; color: #fff;
      font-family: sans-serif; text-shadow:0 1px 3px rgba(0,0,0,.6);
    }
    #score { font-size: 20px; }
    #hint { font-size: 13px; opacity:.9; margin-top:6px; }
    #gameOver {
      position: absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      color:#fff; font-family: sans-serif; text-align:center; display:none;
      text-shadow:0 1px 3px rgba(0,0,0,.6);
    }
    button { font-size:18px; padding:8px 14px; margin-top:12px; }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="score">Score: 0</div>
    <div id="hint">Space / Click / Tap to flap • First-person view (you're the bird)</div>
  </div>
  <div id="gameOver">
    <div id="goText" style="font-size:36px;font-weight:700">Game Over</div>
    <div id="finalScore" style="font-size:20px;margin-top:8px"></div>
    <button id="restartBtn">Restart</button>
  </div>

  <!-- three.js from CDN -->
  <script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>

  <script>
  // --- Basic scene / camera / renderer ---
  const scene = new THREE.Scene();

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  document.body.appendChild(renderer.domElement);

  // Bird (we'll attach the camera to bird position)
  const bird = new THREE.Object3D();
  bird.position.set(0, 1.6, 0); // eye height
  scene.add(bird);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  camera.position.set(0, 0, 0); // camera local to bird
  bird.add(camera);

  // Simple lighting
  const ambient = new THREE.HemisphereLight(0xffffee, 0x4444ff, 0.9);
  scene.add(ambient);

  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5, 10, 5);
  scene.add(dir);

  // Ground plane far ahead (you'll see it approach)
  const groundGeo = new THREE.PlaneGeometry(1000, 1000);
  const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -2;
  scene.add(ground);

  // Subtle horizon fog
  scene.fog = new THREE.FogExp2(0x87CEEB, 0.01);

  // --- Pipe obstacles ---
  const pipeGroup = new THREE.Group();
  scene.add(pipeGroup);

  const pipeMaterial = new THREE.MeshPhongMaterial({ color: 0x008040 });
  const pipeRadius = 1.8;
  const pipeThickness = 2.4; // width of single pipe
  const gapSizeBase = 3.0;

  // Helper: create one pipe (box) — we will use two per obstacle (top and bottom)
  function createPipe(w,h) {
    const g = new THREE.BoxGeometry(w, h, 2.4);
    return new THREE.Mesh(g, pipeMaterial);
  }

  // Game variables
  let velocity = 0;               // vertical velocity of bird
  const gravity = -9.2;          // gravity (m/s^2 approx)
  const flapPower = 4.2;         // instantaneous upward velocity
  const forwardSpeed = 10.0;     // how fast the world moves towards the bird (z direction)
  const pipeSpawnInterval = 1.6; // seconds between pipes
  let lastSpawn = 0;
  let pipes = [];                // array of {group, z, scored}
  let running = true;
  let score = 0;

  // Time bookkeeping
  let lastTime = performance.now() / 1000;

  // Starting camera local tilt to give sense of motion
  let camTilt = 0;

  // Create a small visible beak/wings option? We'll hide the bird mesh in first-person.
  // (If you want a 3rd-person version later, we can add a visible bird model.)

  // Input handling
  function flap() {
    if (!running) return;
    velocity = flapPower;
    camTilt = 0.35;
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      flap();
    }
    if (e.code === 'KeyR') restart();
  });
  window.addEventListener('mousedown', (e) => flap());
  window.addEventListener('touchstart', (e) => { e.preventDefault(); flap(); }, {passive:false});

  // Resize
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });

  // Spawn a pipe pair ahead at z = spawnZ
  const spawnZ = -80;
  function spawnPipes() {
    const gapSize = gapSizeBase + Math.random() * 1.8 - Math.min(score * 0.03, 1.3); // tiny difficulty ramp
    const centerY = (Math.random() * 4 - 1); // center of gap
    const topHeight = 30;
    const bottomHeight = 30;

    const pipePair = new THREE.Group();

    // Top pipe (positioned so its bottom is at centerY + gap/2)
    const topPipe = createPipe(pipeThickness, topHeight);
    topPipe.position.set(0, centerY + gapSize/2 + topHeight/2, spawnZ);
    pipePair.add(topPipe);

    // Bottom pipe
    const bottomPipe = createPipe(pipeThickness, bottomHeight);
    bottomPipe.position.set(0, centerY - gapSize/2 - bottomHeight/2, spawnZ);
    pipePair.add(bottomPipe);

    // Slight horizontal offset (simulate variety) and random rotation
    pipePair.position.x = (Math.random() - 0.5) * 2.0;
    pipePair.userData = { scored: false, gapCenterY: centerY, gapSize };

    pipeGroup.add(pipePair);
    pipes.push({ group: pipePair, z: spawnZ });
  }

  // Collision detection: Treat camera as small sphere at world position birdWorldPos
  const birdRadius = 0.4;

  function worldPositionOf(obj) {
    const v = new THREE.Vector3();
    obj.getWorldPosition(v);
    return v;
  }

  function checkCollisions() {
    const birdPos = worldPositionOf(camera); // camera is local to bird; that's the eye
    for (let i = 0; i < pipes.length; i++) {
      const p = pipes[i].group;
      // Each pipe child is a box (top and bottom)
      for (let child of p.children) {
        const box = new THREE.Box3().setFromObject(child);
        // Expand box slightly to be fair
        box.expandByScalar(0.05);
        // Approx sphere-box collision: check distance from sphere center to box
        const clamp = birdPos.clone();
        clamp.x = Math.max(box.min.x, Math.min(birdPos.x, box.max.x));
        clamp.y = Math.max(box.min.y, Math.min(birdPos.y, box.max.y));
        clamp.z = Math.max(box.min.z, Math.min(birdPos.z, box.max.z));
        const dist2 = clamp.distanceToSquared(birdPos);
        if (dist2 <= (birdRadius * birdRadius)) {
          return true;
        }
      }
    }
    // ground or ceiling hit
    if (bird.position.y - 0.1 <= -2.0 || bird.position.y >= 12) return true;
    return false;
  }

  // UI updates
  const scoreEl = document.getElementById('score');
  const goBox = document.getElementById('gameOver');
  const finalScore = document.getElementById('finalScore');
  document.getElementById('restartBtn').addEventListener('click', restart);

  function setGameOver() {
    running = false;
    goBox.style.display = 'block';
    finalScore.textContent = `Final score: ${score}`;
  }

  function restart() {
    // Reset state
    running = true;
    score = 0;
    scoreEl.textContent = `Score: ${score}`;
    goBox.style.display = 'none';
    // Remove pipes
    for (let p of pipes) {
      pipeGroup.remove(p.group);
    }
    pipes = [];
    bird.position.set(0, 1.6, 0);
    velocity = 0;
    lastSpawn = 0;
    lastTime = performance.now() / 1000;
  }

  // Add some distant clouds/landmarks to give speed cue
  function addDistant() {
    const geom = new THREE.BoxGeometry(6, 1.5, 0.2);
    const mat = new THREE.MeshLambertMaterial({ color: 0xffffff, transparent:true, opacity:0.95 });
    for (let i = 0; i < 18; i++) {
      const m = new THREE.Mesh(geom, mat);
      m.position.set((Math.random()-0.5)*30, 5 + Math.random()*6, -20 - i*10 - Math.random()*40);
      m.rotation.set(0, Math.random()*Math.PI*2, 0);
      scene.add(m);
    }
  }
  addDistant();

  // Main loop
  function animate() {
    const now = performance.now() / 1000;
    let dt = now - lastTime;
    lastTime = now;
    if (dt > 0.05) dt = 0.05; // clamp big frametime

    if (running) {
      // physics
      velocity += gravity * dt;
      bird.position.y += velocity * dt;

      // small forward bob effect
      bird.position.x += 0; // bird stays horizontally near center

      // camera tilt easing
      camTilt = camTilt * 0.9;
      camera.rotation.x = camTilt;

      // spawn pipes
      lastSpawn += dt;
      if (lastSpawn > pipeSpawnInterval) {
        lastSpawn = 0;
        spawnPipes();
      }

      // move pipes toward the bird (increase z)
      for (let i = pipes.length - 1; i >= 0; i--) {
        const pObj = pipes[i];
        pObj.z += forwardSpeed * dt; // world moves z positive toward camera
        pObj.group.children.forEach(child => child.position.z = pObj.z);
        // score check: when pipe passes z > 0 and not scored
        if (!pObj.group.userData.scored && pObj.z > 1.5) {
          pObj.group.userData.scored = true;
          score++;
          scoreEl.textContent = `Score: ${score}`;
        }
        // remove far past pipes
        if (pObj.z > 40) {
          pipeGroup.remove(pObj.group);
          pipes.splice(i,1);
        }
      }

      // collision
      if (checkCollisions()) {
        setGameOver();
      }
    }

    // Give the illusion of forward movement: slightly move the world (sky/ground fog)
    // (Bird stays at z=0; pipes move).

    // subtle camera bob/tilt based on velocity
    camera.rotation.z = Math.max(-0.12, Math.min(0.12, -velocity * 0.02));
    camera.rotation.x = Math.max(-0.6, Math.min(0.6, camera.rotation.x));

    // Render
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  }

  // Kick off
  lastTime = performance.now() / 1000;
  // Pre-spawn a few pipes spaced out so game doesn't start empty
  for (let i = 0; i < 4; i++) {
    spawnPipes();
    // space them
    pipes[pipes.length-1].z = spawnZ - i * 18;
    pipes[pipes.length-1].group.children.forEach(c => c.position.z = pipes[pipes.length-1].z);
  }

  animate();

  // Tips: simple cheat to reset if stuck
  window.resetBird = function(){ bird.position.y = 2; velocity = 0; };

  </script>
</body>
</html>
